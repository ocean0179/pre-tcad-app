# -*- coding: utf-8 -*-
"""MOSFET 소자 적합성 평가 시스템 최종.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15wzFSxZh_sJvQK3Ws9uE6y7lyBuUkc9-

“Pre-TCAD material screener”


[목적]

-외부 파일 없이 코랩 한 셀로 바로 돌릴 수 있는 MOSFET 간이 스크리너.

-CGCNN으로 도출한 재료 물성(Eg, εr, 형성에너지) + 공정/설계 슬라이더(tox, εox, NA, L, VDD, T, W, μ)를 바꾸면
SS, Vth, Ion, gm, fT, r0, DIBL, 안정성 점수 등을 계산하고,
동일 조건에서 기준 재료군(Si, Ge, GaN, MoS2, …)과 비교한 ‘백분위(%)’를 보여준다.






[설계 원칙]
- φF(페르마 전위)는 ni 기반 표준식을 썼는데, ni는 Eg로부터 단순 근사해서 자동으로 만든다.
  (즉, 사용자가 별도로 ni를 넣을 필요는 없음.)
- Vth는 MOSFET 기본식 Vth = φms + 2φF + (√(2εs q NA · 2φF))/Cox 를 그대로 썼다.
- Vov≤0(OFF) OFF 상태에서 Id≈0일 때 r0가 비정상적으로 커지는 현상은 0으로 잘라서 순위 왜곡을 막는다. Ion/gm/fT=0, r0도 0 처리
- fT, DIBL은 간단 모델이므로 절대값보다는 ‘서로 비교할 때’ 의미가 있다.
- 베이스라인 재료 12종을 동일 공정조건으로 계산 → 그래프에 점으로 함께 표시해 직관적 비교
- 퍼센트는 지표별 물리 범위(사전 정의)로 정규화, 로그스케일이 자연스러운 지표는 log10 변환 후 선형 매핑
'''
"""

# -------------------------------- Imports & Setup --------------------------------
from dataclasses import dataclass
from typing import Dict, List
import math
import pandas as pd
import matplotlib.pyplot as plt
import ipywidgets as w
from IPython.display import display, clear_output
from IPython import get_ipython


ip = get_ipython()
if ip:
    ip.run_line_magic("matplotlib", "inline")
plt.rcParams["figure.dpi"] = 120

# -------------------------------- Constants --------------------------------
EPS0 = 8.854e-12  # [F/m] 진공 유전율 ε0
Q    = 1.602e-19  # [C]   전자 기본 전하 q


# 게이트 금속-반도체 일함수 차 φ_ms (nMOS 가정)
#   - 음수면 Vth를 낮추는 효과(낮은 일함수 금속 채택처럼 작동)
#   - 0.0으로 두면 순수 산화막/도핑/재료만으로 결정
PHI_MS_V = -0.25   # [V] 0 ~ -0.4 정도에서 조정 가능

# -------------------------------- Input Data classes --------------------------------
@dataclass
class MaterialInputs:
   """
    채널 재료가 가진 기본 물성.
    - Eg_eV: 밴드갭 [eV]
      · 전자가 가전자대→전도대로 이동하기 위한 최소 에너지차.
      · Eg↑ → 전류 누설 감소(Ioff↓), 문턱전압(Vth) 상승, OFF 특성 개선.

    - eps_r: 반도체 상대 유전율
      · 내부 전기장에 대한 분극 정도 (εs = εr * ε0).
      · SS, Vth 계산 시 공핍층 커패시턴스(Cd)에 직접 영향.
      · εr↑ → 전하 제어 약화, SS 악화 가능.

    - Ef_eV_atom:  형성에너지 [eV/atom], 더 작을수록 안정하다고 본다.
      · 재료가 원소 상태에서 형성될 때의 안정성 지표 (음수일수록 안정).
      · 전기적 계산에는 직접 쓰이지 않지만, 안정성 점수(stability_score) 계산에 사용.
    """
   Eg_eV: float
   eps_r: float
   Ef_eV_atom: float


@dataclass
class SliderParams:
    """
    공정/설계 변수(슬라이더):
      - tox_nm: 산화막 두께 [nm]          → 얇을수록 Cox↑ → SS 개선, Vth↓, Ion/gm/fT↑
      - eps_ox: 산화막 상대유전율         → 클수록 Cox↑ → 동일 효과
      - NA_cm3: 채널/바디 도핑(p형 도핑 농도) [cm^-3]    → 클수록 φF↑ → Vth↑, SS 악화 가능
      - L_nm:   채널 길이 [nm]            → 짧을수록 W/L↑로 Ion/gm↑, fT↑. DIBL 악화
      - VDD_V:  동작 전압 [V]             → 클수록 Vov↑ → Ion/gm/fT↑
      - T_K:    절대온도 [K]                  → 높을수록 ni↑ → φF↓ → Vth↓ (누설↑ 가능)
      - W_um:   채널 폭 [μm]              → per-μm 출력을 위해 내부 계산용
      - mu_cm2_Vs: 이동도 [cm^2/Vs]       → 클수록 Ion/gm↑
    """
    tox_nm: float = 8.0
    eps_ox: float = 20.0
    NA_cm3: float = 1e15
    L_nm: float   = 40.0
    VDD_V: float  = 0.9
    T_K: float    = 330.0
    W_um: float   = 1.0
    mu_cm2_Vs: float = 300.0

# -------------------------------- Unit helpers --------------------------------
def cm2_to_m2(x): return float(x) * 1e-4        # [cm^2] → [m^2]

def cm3_to_m3(x): return float(x) * 1e6         # [cm^-3] → [m^-3]

def nm_to_m(x):   return float(x) * 1e-9        # [nm] → [m]

def um_to_m(x):   return float(x) * 1e-6        # [μm] → [m]

# -------------------------------- Semiconductor formulas --------------------------------
def kT_over_q(T_K: float):
    """열전압 V_T = kT/q [V] : 실온(300K)에서 약 0.02585 V"""
    return 8.617333262145e-5 * float(T_K)

def Cox_Fperm2(eps_ox, tox_nm):
    """산화막 커패시턴스 밀도 C_ox [F/m^2] = ε_ox ε0 / t_ox"""
    return (float(eps_ox) * EPS0) / nm_to_m(tox_nm)

def eps_sem_Fperm(eps_r):
    """반도체 유전율 ε_s [F/m] = ε_r ε0"""
    return float(eps_r) * EPS0

def ni_from_Eg(Eg_eV: float, T_K: float):
    """
    진성 캐리어 농도 ni를 Eg에서 대략적으로 추정.
    - 기준: Si 300K에서 ni ≈ 1e10 cm^-3
    - Eg가 커지면 ni는 지수로 감소
    - 정확한 값은 재료 DB를 써야 하지만, 여기서는 입력을 단순화하기 위해 이렇게 둔다.
    """
    Vt = kT_over_q(T_K)
    # Eg가 1.12eV보다 크면 exp(음수) → ni 작아짐
    ni = 1e10 * math.exp((1.12 - float(Eg_eV)) / (2.0 * Vt))
    # 너무 비현실적으로 작아지는 것 방지
    return max(ni, 1.0)

def phi_F(Eg_eV: float, NA_cm3: float, T_K: float):
    """
    페르미 전위 φF = V_T * ln(NA / ni)
    - NA는 도핑, ni는 위에서 Eg 기반으로 계산.
    - φF가 너무 0에 가까우면 뒤 계산에서 폭주하므로 0.02 V 하한을 둔다.
    - ni는 Si(300K)≈1e10 cm^-3을 기준으로 Eg 차이에 대해 지수 보정(단순 근사)
    - Eg↑ → ni↓ → φF↑ (보수적 경향)
    """
    Vt = kT_over_q(T_K)
    # Eg 차이에 따른 ni 보정 (Nc,Nv 동일 가정의 간단 근사)
    ni_cm3 = 1e10 * math.exp((1.12 - float(Eg_eV)) / (2.0 * Vt))
    # 가드
    ni_cm3 = max(ni_cm3, 1.0)
    NA_cm3 = max(float(NA_cm3), 1.0)
    phi = Vt * math.log(NA_cm3 / ni_cm3)
    return max(phi, 0.02)  # 지나치게 작은 φF 방지용 하한

def Cd_Fperm2(eps_r: float, NA_cm3: float, Eg_eV: float, T_K: float):
    """
    공핍 커패시턴스 밀도 C_d [F/m^2] ~ sqrt( q ε_s NA / (2 φF) )
    - 도핑↑, ε_s↑, φF↓ → C_d↑ → SS 악화
    """
    epss = eps_sem_Fperm(eps_r)
    phi  = phi_F(Eg_eV, NA_cm3, T_K)
    return math.sqrt((Q * epss * cm3_to_m3(NA_cm3)) / (2.0 * phi))

# -------------------------------- Core metrics --------------------------------
def SS_mVdec(m: MaterialInputs, s: SliderParams):
    """
    서브스레숄드 스윙
    SS [mV/dec] = ln(10) V_T (1 + C_d/C_ox)
    - C_d/C_ox가 작을수록 SS가 이상적(60~70 mV/dec @ 300K 근처)
    """
    Vt  = kT_over_q(s.T_K)
    cd  = Cd_Fperm2(m.eps_r, s.NA_cm3, m.Eg_eV, s.T_K)
    cox = Cox_Fperm2(s.eps_ox, s.tox_nm)
    return math.log(10.0) * Vt * (1.0 + cd/cox) * 1e3

def Vth_V(m: MaterialInputs, s: SliderParams):
    """
    MOSFET 기본 문턱전압식
    Vth = φ_ms + 2φF + ( √(2 ε_s q N_A · 2φF) ) / C_ox
    - φ_ms = PHI_MS_V: 금속-반도체 일함수 차이 (상단 상수로 조정)
    - 2φF: 반전을 만들기 위한 전위
    - 마지막 항: 공핍전하를 산화막 커패시턴스로 나눈 항
    - 도핑↑, ε_s↑ → 루트항↑ → Vth↑
    - C_ox↑(= tox↓, ε_ox↑) → 루트항/Cox↓ → Vth↓
    """
    epss = eps_sem_Fperm(m.eps_r)
    phi  = phi_F(m.Eg_eV, s.NA_cm3, s.T_K)
    cox  = Cox_Fperm2(s.eps_ox, s.tox_nm)
    return PHI_MS_V + 2.0*phi + math.sqrt(2.0 * epss * Q * cm3_to_m3(s.NA_cm3) * (2.0*phi)) / cox

def Ioff_proxy(m: MaterialInputs, s: SliderParams):
    """
    OFF 전류를 단순 대용치 (절대값X, 경향성만)
    - 실제: Ioff = I0 * exp(-(Vth)/(n Vt))
    - ~exp(-Eg / V_T) : Eg가 클수록 누설↓ (지수로 감소)
    """
    Vt = kT_over_q(s.T_K)
    val = math.exp(-m.Eg_eV / max(Vt, 1e-6))
    return max(val, 1e-300)  # 언더플로우 방지

def mu_SI(mu_cm2_Vs: float):
    """이동도 단위 변환 [cm^2/Vs] → [m^2/Vs]"""
    return cm2_to_m2(mu_cm2_Vs)

def Id_on_A_per_um(m: MaterialInputs, s: SliderParams):
    """
    포화 영역 근사식
    Id ≈ (1/2) * μ * C_ox * (W/L) * V_ov^2 (단, V_ov = VDD - Vth)
    - per μm 단위로 보기 위 마지막에 W_um으로 나눠 [A/μm] 출력
    """
    Vov = s.VDD_V - Vth_V(m, s)
    if Vov <= 0.0:
        return 0.0
    mu  = mu_SI(s.mu_cm2_Vs)
    cox = Cox_Fperm2(s.eps_ox, s.tox_nm)
    W = um_to_m(s.W_um); L = nm_to_m(s.L_nm)
    return (0.5 * mu * cox * (W/L) * (Vov**2)) / s.W_um

def gm_S_per_um(m: MaterialInputs, s: SliderParams):
    """
    트랜스컨덕턴스 근사
    gm ≈ μ C_ox (W/L) V_ov  (포화 근사)
    - per μm 기준 [S/μm]
    """
    Vov = s.VDD_V - Vth_V(m, s)
    if Vov <= 0.0:
        return 0.0
    mu  = mu_SI(s.mu_cm2_Vs)
    cox = Cox_Fperm2(s.eps_ox, s.tox_nm)
    W = um_to_m(s.W_um); L = nm_to_m(s.L_nm)
    return (mu * cox * (W/L) * Vov) / s.W_um

def ft_Hz(m: MaterialInputs, s: SliderParams):
    """
    전이 주파수 근사
    - fT ≈ gm / (2π Cgg)
    - 단, 여기서는 Cgg = C_ox * W * L으로 단순화
    """
    gm_tot = gm_S_per_um(m, s) * s.W_um   # per-μm → 전체 gm
    cox    = Cox_Fperm2(s.eps_ox, s.tox_nm)
    Cgg    = cox * um_to_m(s.W_um) * nm_to_m(s.L_nm)
    if gm_tot <= 0.0 or Cgg <= 0.0:
        return 0.0
    return gm_tot / (2.0 * math.pi * Cgg)

def r0_ohm_per_um(m: MaterialInputs, s: SliderParams):
    """
    출력저항 근사
    - r0 ≈ 1 / (λ Id) (채널 길이 변조 λ ~ 1/L 가정)
    - OFF 상태에서 Id≈0일 때 r0가 무한대로 가는 걸 막기 위해,
      Vov<=0이면 r0=0.0 처리 (순위 왜곡 방지)
    """
    Vov = s.VDD_V - Vth_V(m, s)
    if Vov <= 0.0:
        return 0.0
    # 기준 길이 50 nm에서 λ≈0.02 라고 가정한 간단 모델
    L0_nm, lambda0 = 50.0, 0.02
    lam = lambda0 * (L0_nm / max(s.L_nm, 1e-9))
    Id  = max(Id_on_A_per_um(m, s), 1e-15)
    return 1.0 / (lam * Id)

def dibl_proxy_mV_per_V(m: MaterialInputs, s: SliderParams):
    """
    DIBL을 아주 단순하게 본 버전.
    (실제 DIBL은 2D 전기장 문제라 정확식이 없고,
    여기서는 tox/L 비율이 커질수록, 채널 유전율이 작을수록 DIBL이 커진다고 본다.)
    - DIBL 대용치 ~ 100 * (tox/L) * (1/εr)
    - L이 짧고, 산화막 두껍고, 반도체 εr 낮을수록 악화
    - 절대치X, '경향성' 지표
    """
    return 100.0 * (s.tox_nm / max(s.L_nm, 1e-9)) * (1.0 / max(m.eps_r, 1e-6))

def stability_score(m: MaterialInputs):
    """
    형성에너지 기반 안정성 점수. sigmoid(Ef)
    - Ef가 더 낮을수록(안정할수록) 점수↑ (0~1 스케일)
    - -1.5 eV/atom 정도면 거의 1에 가깝게,
    0 eV/atom에 가까우면 0에 가깝게 떨어지도록 시그모이드 사.
    """
    return 1.0 / (1.0 + math.exp(m.Ef_eV_atom + 0.5))

def compute_metrics(m: MaterialInputs, s: SliderParams):
    return {
        "SS_mVdec":        SS_mVdec(m, s),
        "Vth_V":           Vth_V(m, s),
        "Ion_A_per_um":    Id_on_A_per_um(m, s),
        "Ioff_proxy":      Ioff_proxy(m, s),
        "gm_S_per_um":     gm_S_per_um(m, s),
        "ft_Hz":           ft_Hz(m, s),
        "r0_ohm_per_um":   r0_ohm_per_um(m, s),
        "DIBL_mV_per_V":   dibl_proxy_mV_per_V(m, s),
        "Stab_score":      stability_score(m),
    }

# -------------------------------- Baseline materials --------------------------------
BASELINE = [
    ("Si",    1.12, 11.7, -1.0),
    ("Ge",    0.66, 16.0, -0.8),
    ("GaAs",  1.42, 12.9, -1.2),
    ("InP",   1.34, 12.4, -1.1),
    ("InGaAs",0.75, 13.9, -1.0),
    ("SiC",   3.26,  9.7, -1.5),
    ("GaN",   3.40,  9.5, -1.3),
    ("Ga2O3", 4.80, 10.0, -1.6),
    ("ZnO",   3.30,  9.0, -1.2),
    ("IGZO",  3.00, 10.0, -1.0),
    ("MoS2",  1.80,  8.0, -1.1),
    ("WS2",   1.90,  7.2, -1.1),
]

def build_distributions(s: SliderParams) -> Dict[str, List[float]]:
    """
    동일 공정조건 s에서 베이스라인 재료 각각의 메트릭을 계산해 지표별 리스트를 만든다.
    (그래프에 점으로 표시할 때 사용)
    """
    keys = ["SS_mVdec","Vth_V","Ion_A_per_um","Ioff_proxy","gm_S_per_um","ft_Hz",
            "r0_ohm_per_um","DIBL_mV_per_V","Stab_score"]

    """
    같은 공정 슬라이더(s)를 모든 기준 재료에 적용해서
    각 지표가 어떤 분포를 가지는지 만듦.
    이 분포와 현재 재료를 비교해서 백분위를 구할 수 있음.
    """
    dist = {k: [] for k in keys}
    for name, Eg, epsr, Ef in BASELINE:
        m = MaterialInputs(Eg, epsr, Ef)
        met = compute_metrics(m, s)
        for k in keys:
            dist[k].append(met[k])
    return dist

# -------------------------------- Percentiles (physical ranges) --------------------------------
def percentile_physical(value: float, key: str, smaller_is_better: bool = False):
    """
    dataset을 통해 value가 몇 % 위치에 있는지 계산.
    - 각 지표(key)에 대해 물리적으로 가능한 최소/최대 범위를 지정하고,
    - 그 범위 안에서 0~100%로 선형 매핑한다.(dataset 대신 물리적 기준으로 비교)
    - 성능이 클수록 좋은 지표면 그대로
    - 작을수록 좋은 지표면 (100 - rank)
    - 범위에 20% 버퍼를 추가한 뒤 0.5~99.5%로 소프트 클리핑.
    """
    # 1) 넓힌 물리 범위
    ranges = {
        "SS_mVdec":        (40.0, 200.0),   # mV/dec
        "Vth_V":           (0.0,  1.5),     # V
        "Ion_A_per_um":    (1e-9,  1e-1),   # A/μm  (상한↑)
        "Ioff_proxy":      (1e-30, 1e-3),   # proxy (상한 완화)
        "gm_S_per_um":     (1e-7,  1e-1),   # S/μm  (범위↑)
        "ft_Hz":           (1e8,   1e14),   # Hz    (범위↑)
        "r0_ohm_per_um":   (1e2,   1e9),    # Ω·μm  (상한↑)
        "DIBL_mV_per_V":   (0.0,   200.0),  # mV/V
        "Stab_score":      (0.0,   1.0),    # 0~1
    }
    vmin, vmax = ranges.get(key, (0.0, 1.0))
    val = float(value)

    # 2) 로그 스케일로 다루는 지표들
    log_keys = {"Ion_A_per_um","Ioff_proxy","gm_S_per_um","ft_Hz","r0_ohm_per_um"}
    if key in log_keys:
        val  = math.log10(max(val, 1e-300))
        vmin = math.log10(vmin)
        vmax = math.log10(vmax)

    # 3) 20% 버퍼로 범위 확장 (소프트 클리핑 효과)
    span = vmax - vmin
    vmin_b = vmin - 0.2 * span
    vmax_b = vmax + 0.2 * span

    # 4) 퍼센트 변환
    pct = (val - vmin_b) / (vmax_b - vmin_b) * 100.0

    # 5) 끝단에서 0/100 딱 붙지 않도록 소프트 클램프
    pct = max(0.5, min(99.5, pct))

    # 6) 작은 게 좋은 지표는 뒤집기
    return 100.0 - pct if smaller_is_better else pct


def compute_percentiles(metrics: Dict[str, float]):
    """
    물리 범위 + 소프트 클리핑 기반 퍼센트.
    Vth는 기본 목표 0.45 V, spread=0.2에서 가우시안형 점수(끝단 0% 방지).
    """
    p: Dict[str, float] = {}

    # 작은 게 좋은 지표
    p["SS_percent"]   = percentile_physical(metrics["SS_mVdec"],      "SS_mVdec",      True)
    p["DIBL_percent"] = percentile_physical(metrics["DIBL_mV_per_V"], "DIBL_mV_per_V", True)

    # Vth: 선형 대신 완만한 가우시안형 (끝단 0% 방지)
    target_vth, sigma = 0.45, 0.20   # sigma≈spread
    err = (metrics["Vth_V"] - target_vth) / max(sigma, 1e-9)
    vth_score = 100.0 * math.exp(-(err**2))
    # 소프트 클램프
    p["Vth_score_percent"] = max(0.5, min(99.5, vth_score))

    # 큰 게 좋은 지표
    p["Ion_percent"]  = percentile_physical(metrics["Ion_A_per_um"],  "Ion_A_per_um",  False)
    p["Ioff_percent"] = percentile_physical(metrics["Ioff_proxy"],    "Ioff_proxy",    True)   # 작을수록 좋음
    p["gm_percent"]   = percentile_physical(metrics["gm_S_per_um"],   "gm_S_per_um",   False)
    p["fT_percent"]   = percentile_physical(metrics["ft_Hz"],         "ft_Hz",         False)
    p["r0_percent"]   = percentile_physical(metrics["r0_ohm_per_um"], "r0_ohm_per_um", False)
    p["Stab_percent"] = percentile_physical(metrics["Stab_score"],    "Stab_score",    False)

    return p

# -------------------------------- Widgets --------------------------------
# 기본값: Si CMOS + HKMG(HfO2 + Metal Gate) 프리셋
Eg_eV      = w.FloatSlider(value=1.12, min=0.2, max=5.0,  step=0.02,
                           description='Eg (eV)',        continuous_update=True)      # Si 밴드갭
eps_r      = w.FloatSlider(value=11.7, min=1.0, max=30.0, step=0.1,
                           description='εr (semi)',      continuous_update=True)      # Si 상대유전율
Ef_eV_atom = w.FloatSlider(value=-1.0, min=-3.0, max=1.0, step=0.05,
                           description='E_form (eV/atom)', continuous_update=True)     # 안정성 점수용 스케일

tox_nm  = w.FloatSlider(value=1.5,  min=0.5, max=30.0, step=0.1,
                        description='tox (nm)',         continuous_update=True)       # HKMG 유효 두께(인터페이스 포함)
eps_ox  = w.FloatSlider(value=20.0, min=2.0,  max=30.0, step=0.1,
                        description='εr (ox)',          continuous_update=True)       # HfO2 대푯값

NA_cm3  = w.FloatLogSlider(value=1e17, base=10, min=14, max=19, step=0.05,
                           description='NA (cm⁻³)',      continuous_update=True)       # 바디 도핑(중간값)
L_nm    = w.FloatSlider(value=30.0, min=5.0,  max=200.0, step=1.0,
                        description='L (nm)',            continuous_update=True)       # 채널 길이
VDD_V   = w.FloatSlider(value=0.70, min=0.2,  max=1.2,  step=0.01,
                        description='VDD (V)',           continuous_update=True)       # 최신 CMOS 범위
T_K     = w.FloatSlider(value=300.0, min=200.0, max=500.0, step=1.0,
                        description='T (K)',             continuous_update=True)       # 실온
W_um    = w.FloatSlider(value=1.0,  min=0.05, max=50.0, step=0.05,
                        description='W (μm)',            continuous_update=True)
mu_cm2_Vs= w.FloatSlider(value=250.0, min=1.0, max=2000.0, step=1.0,
                         description='μ (cm²/Vs)',       continuous_update=True)       # 채널 유효 이동도(보수적)

out = w.Output()

# 지수 표기 헬퍼
def fmt_sci(x):
    try:
        f = float(x)
        if f == 0.0:
            return "0"
        if (abs(f) < 1e-3) or (abs(f) >= 1e4):
            return f"{f:.3e}"
        else:
            return f"{f:.6f}"
    except Exception:
        return str(x)

# ===== 과학표기 + '0처럼 보임' 방지 포맷터 (update 위쪽에 한 번 정의되어 있어야 함) =====
def fmt_floor_e(x, floor=1e-40):
    try:
        f = float(x)
        if 0 < f < floor:
            return f"<{floor:.0e}"
        return f"{f:.3e}"
    except Exception:
        return str(x)

# ---- 베이스라인 점 색/라벨 설정 (BASELINE이 위에 정의되어 있어야 함) ----
BASE_NAMES = [name for (name, *_ ) in BASELINE]
CMAP = plt.get_cmap('tab20')
MATERIAL_COLORS = {name: CMAP(i % 20) for i, name in enumerate(BASE_NAMES)}

# ---- 범례에 퍼센트를 붙일 지표 선택 드롭다운 ----
legend_metric_options = [
    ("Ion",            "Ion_percent"),
    ("gm",             "gm_percent"),
    ("fT",             "fT_percent"),
    ("r0",             "r0_percent"),
    ("Ioff(역수기반)", "Ioff_percent"),
    ("SS",             "SS_percent"),
    ("DIBL",           "DIBL_percent"),
    ("Vth score",      "Vth_score_percent"),
    ("Stability",      "Stab_percent"),
]
legend_metric_dd = w.Dropdown(
    options=legend_metric_options,
    value="Ion_percent",
    description="Legend:",
    layout=w.Layout(width="260px")
)

# --- ① 분포 기반 퍼센트(패딩 포함) : 교체본 ---
def compute_percentiles_from_dist(metrics, dist, pad):
    """
    모든 퍼센트 지표를 '분포 + pad'로 계산.
    - pad: 분포 끝을 양쪽으로 확장(0.0~1.5 권장), 끝단 0/100은 0.5~99.5로 소프트 클램프
    - Vth: 베이스라인 분포(패딩 적용) 대비 타깃(0.45V) 근접도 점수
    """
    def _percent_from_dist(val, dataset, smaller_is_better=False, pad=0.50):
        ds = [float(x) for x in dataset if math.isfinite(x)]
        if not ds:
            return float('nan')
        vmin0, vmax0 = min(ds), max(ds)
        if vmax0 == vmin0:
            return 50.0
        span = vmax0 - vmin0
        vmin = vmin0 - pad * span
        vmax = vmax0 + pad * span
        p = 100.0 * (float(val) - vmin) / (vmax - vmin)
        if smaller_is_better:
            p = 100.0 - p
        return max(0.5, min(99.5, p))  # 0/100 고정 방지

    def _vth_score_from_dist(vth, dataset, pad, target=0.45):
        """베이스라인 분포(패딩 포함) 대비 타깃 근접도 점수(0.5~99.5%)."""
        ds = [float(x) for x in dataset if math.isfinite(x)]
        if not ds:
            return float('nan')
        vmin0, vmax0 = min(ds), max(ds)
        if vmax0 == vmin0:
            return 50.0
        span0 = vmax0 - vmin0
        vmin = vmin0 - pad * span0
        vmax = vmax0 + pad * span0
        tgt = min(max(target, vmin), vmax)     # 타깃을 분포 범위로 클램프
        half = max(1e-12, 0.5 * (vmax - vmin))
        d = abs(float(vth) - tgt) / half       # 0(완전일치) → 1(끝단)
        score = (1.0 - d) * 100.0
        return max(0.5, min(99.5, score))

    p = {}
    # 작은 게 좋은 것들
    p["SS_percent"]   = _percent_from_dist(metrics["SS_mVdec"],       dist["SS_mVdec"],       True,  pad)
    p["DIBL_percent"] = _percent_from_dist(metrics["DIBL_mV_per_V"],  dist["DIBL_mV_per_V"],  True,  pad)

    # Vth: 분포-기반 근접도
    p["Vth_score_percent"] = _vth_score_from_dist(metrics["Vth_V"], dist["Vth_V"], pad, target=0.45)

    # 큰 게 좋은 것들
    p["Ion_percent"]  = _percent_from_dist(metrics["Ion_A_per_um"],   dist["Ion_A_per_um"],   False, pad)
    p["gm_percent"]   = _percent_from_dist(metrics["gm_S_per_um"],    dist["gm_S_per_um"],    False, pad)
    p["fT_percent"]   = _percent_from_dist(metrics["ft_Hz"],          dist["ft_Hz"],          False, pad)
    p["r0_percent"]   = _percent_from_dist(metrics["r0_ohm_per_um"],  dist["r0_ohm_per_um"],  False, pad)
    p["Stab_percent"] = _percent_from_dist(metrics["Stab_score"],     dist["Stab_score"],     False, pad)

    # Ioff: 작을수록 좋음 → 역수 분포로 비교
    inv_val  = 1.0 / max(metrics["Ioff_proxy"], 1e-300)
    inv_dist = [1.0 / max(x, 1e-300) for x in dist["Ioff_proxy"]]
    p["Ioff_percent"] = _percent_from_dist(inv_val, inv_dist, False, pad)

    return p

# --- ② 베이스라인 점/범례 퍼센트 계산 헬퍼 : 함수 아래에 추가 ---
_SMALL_BETTER = {"SS_mVdec", "DIBL_mV_per_V"}

def _baseline_pct_for_key(raw_key, value, dist, pad):
    """분포+pad 규칙으로 baseline 값을 0.5~99.5%로 변환 (범례/산점용)."""
    def _percent_from_dist(val, dataset, smaller_is_better=False, pad=0.50):
        ds = [float(x) for x in dataset if math.isfinite(x)]
        if not ds:
            return float('nan')
        vmin0, vmax0 = min(ds), max(ds)
        if vmax0 == vmin0:
            return 50.0
        span = vmax0 - vmin0
        vmin = vmin0 - pad * span
        vmax = vmax0 + pad * span
        p = 100.0 * (float(val) - vmin) / (vmax - vmin)
        if smaller_is_better:
            p = 100.0 - p
        return max(0.5, min(99.5, p))

    if raw_key == "Ioff_proxy":
        inv_val  = 1.0 / max(value, 1e-300)
        inv_dist = [1.0 / max(x, 1e-300) for x in dist["Ioff_proxy"]]
        return _percent_from_dist(inv_val, inv_dist, False, pad)

    return _percent_from_dist(value, dist[raw_key], (raw_key in _SMALL_BETTER), pad)

# 퍼센트 범위 패딩 조절(0.00~1.50): 0.50 권장
range_pad = w.FloatSlider(value=0.50, min=0.00, max=1.50, step=0.05,
                          description="range pad", continuous_update=True)

# -------------------------------- UI update --------------------------------
from matplotlib.lines import Line2D

def plot_ranking_figure(perc, dist, pad, legend_key="Ion_percent"):
    """
    perc      : compute_percentiles_from_dist(...) 결과 dict
    dist      : build_distributions(...) 결과 dict
    pad       : range_pad (예: 0.50)
    legend_key: 범례에 퍼센트 붙일 지표 이름 (예: "Ion_percent")

    반환값:
      fig : Matplotlib Figure 객체
    """
    # 이 함수 안에서 name_map을 직접 정의 (update에서는 name_map을 전혀 쓰지 않음)
    name_map = {
        "SS_percent":        "SS_mVdec",
        "Vth_score_percent": "Vth_V",
        "Ion_percent":       "Ion_A_per_um",
        "Ioff_percent":      "Ioff_proxy",
        "gm_percent":        "gm_S_per_um",
        "fT_percent":        "ft_Hz",
        "r0_percent":        "r0_ohm_per_um",
        "DIBL_percent":      "DIBL_mV_per_V",
        "Stab_percent":      "Stab_score",
    }

    order_p = [
        "SS_percent", "Vth_score_percent", "Ion_percent", "Ioff_percent",
        "gm_percent", "fT_percent", "r0_percent", "DIBL_percent", "Stab_percent"
    ]

    keys = [k for k in order_p if k in perc]
    vals = [float(perc[k]) for k in keys]

    fig, ax = plt.subplots(figsize=(8.8, 5.4))
    ax.barh(keys, vals)

    # ----- 베이스라인 점 찍기 -----
    for yi, pkey in enumerate(keys):
        raw_key = name_map.get(pkey, None)
        if raw_key is None or raw_key not in dist:
            continue
        for i, bv in enumerate(dist[raw_key]):
            name  = BASE_NAMES[i]
            color = MATERIAL_COLORS.get(name, 'k')
            bpct  = _baseline_pct_for_key(raw_key, bv, dist, pad=pad)
            ax.plot(bpct, yi, 'o', markersize=4, color=color, alpha=0.95)

    # ----- 범례 만들기 (legend_key 기준) -----
    raw_for_legend = name_map.get(legend_key, None)
    legend_handles, legend_labels = [], []

    if raw_for_legend in dist:
        for i, name in enumerate(BASE_NAMES):
            color = MATERIAL_COLORS.get(name, 'k')
            bv = dist[raw_for_legend][i]
            pct = _baseline_pct_for_key(raw_for_legend, bv, dist, pad=pad)
            legend_handles.append(
                Line2D([0], [0], marker='o', linestyle='', color=color, markersize=6)
            )
            legend_labels.append(f"{name} {pct:.1f}%")

    ax.legend(
        legend_handles,
        legend_labels,
        title=f"Baseline ({legend_key})",
        bbox_to_anchor=(1.02, 1.0),
        loc="upper left",
        frameon=False,
        fontsize=8,
        title_fontsize=9,
    )

    # ----- 막대 끝에 퍼센트 숫자 표시 -----
    for y, v in enumerate(vals):
        ax.text(min(v + 1, 99.0), y, f"{v:.1f}%", va="center")

    ax.set_xlim(0, 100)
    ax.set_xlabel("Percentile (%)")
    ax.set_title("Relative Ranking vs Baselines (with range pad)")
    ax.invert_yaxis()
    fig.tight_layout()

    return fig


def update(_=None):
    """슬라이더 값이 바뀔 때마다 표/그래프/디버그를 갱신"""
    with out:
        clear_output(wait=True)  # 즉시 갱신 + 깜빡임 최소화

        # 1) 입력값
        m = MaterialInputs(Eg_eV.value, eps_r.value, Ef_eV_atom.value)
        s = SliderParams(
            tox_nm.value, eps_ox.value, NA_cm3.value, L_nm.value,
            VDD_V.value, T_K.value, W_um.value, mu_cm2_Vs.value
        )

        # 2) 지표 + 분포 + 퍼센트(분포 pad 적용)
        dist = build_distributions(s)
        met  = compute_metrics(m, s)
        perc = compute_percentiles_from_dist(met, dist, pad=range_pad.value)

        # 2-1) 디버그 출력
        Vth = met["Vth_V"]; Vov = s.VDD_V - Vth
        Cox = Cox_Fperm2(s.eps_ox, s.tox_nm)
        Cd  = Cd_Fperm2(m.eps_r, s.NA_cm3, m.Eg_eV, s.T_K)
        print(
            f"[DEBUG] phi_F={phi_F(m.Eg_eV, s.NA_cm3, s.T_K):.3f} V, "
            f"Vth={Vth:.3f} V, Vov={Vov:.3f} V, "
            f"Cox={Cox:.3e} F/m² , Cd={Cd:.3e} F/m²"
        )
        if Vov <= 0.0:
            print(
                " Vov≤0 → 소자가 꺼져 있습니다 (Ion/gm/fT=0, r0=0). "
                "tox↓, εox↑, NA↓, VDD↑, 또는 PHI_MS_V 조정으로 켜보세요."
            )

        # 3) 표 (지금 구조 그대로 유지)
        order_m = [
            "SS_mVdec","Vth_V","Ion_A_per_um","Ioff_proxy","gm_S_per_um","ft_Hz",
            "r0_ohm_per_um","DIBL_mV_per_V","Stab_score"
        ]
        order_p = [
            "SS_percent","Vth_score_percent","Ion_percent","Ioff_percent","gm_percent",
            "fT_percent","r0_percent","DIBL_percent","Stab_percent"
        ]

        df_m = pd.DataFrame(met, index=['value']).T.reindex(order_m)
        df_p = pd.DataFrame(perc, index=['percent']).T.reindex(order_p)

        def _fmt_row(row):
            k = row.name; v = row["value"]
            if k == "SS_mVdec":
                return f"{v:.1f}"
            if k in ("Vth_V","DIBL_mV_per_V","Stab_score"):
                return f"{v:.3f}"
            return fmt_floor_e(v)

        df_m_disp = df_m.copy()
        df_m_disp["value"] = df_m.apply(_fmt_row, axis=1)

        print("\n== Metrics ==")
        display(df_m_disp)
        print("\n== Percentiles (0~100, physical-range normalized) ==")
        display(df_p.style.format("{:.1f}%"))

        # 4) 그래프(점 + 범례) – 여기서는 plot_ranking_figure만 호출
        legend_key = legend_metric_dd.value

        # perc 안에 유효한 숫자 값이 있는지 확인
        vals_for_check = [
            float(perc[k]) for k in order_p
            if (k in perc and isinstance(perc[k], (int, float)))
        ]
        has_valid = any(math.isfinite(v) for v in vals_for_check) if vals_for_check else False

        if has_valid:
            fig = plot_ranking_figure(
                perc=perc,
                dist=dist,
                pad=range_pad.value,
                legend_key=legend_key,
            )
            plt.show(fig)
        else:
            print(" 그래프 생략: 표시할 퍼센트 값이 없음.")


# -------- 옵저버 & 레이아웃 ----------
all_widgets = [Eg_eV, eps_r, Ef_eV_atom, tox_nm, eps_ox, NA_cm3, L_nm, VDD_V,
               T_K, W_um, mu_cm2_Vs, legend_metric_dd, range_pad]

for wid in all_widgets:
    # 중복 등록 방지
    try:
        wid.unobserve(update, names='value')
    except Exception:
        pass
    try:
        wid.continuous_update = True
        wid.observe(update, names='value')
    except Exception:
        pass

ui_left  = w.VBox([Eg_eV, eps_r, Ef_eV_atom])
ui_right = w.VBox([tox_nm, eps_ox, NA_cm3, L_nm, VDD_V, T_K, W_um, mu_cm2_Vs])
ui_top   = w.HBox([legend_metric_dd, range_pad])

display(ui_top)
display(w.HBox([ui_left, ui_right]))
display(out)
update()
